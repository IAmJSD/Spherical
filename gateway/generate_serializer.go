//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"os"
	"sort"
	"strconv"
	"strings"
)

type uint16Sorter struct {
	s []uint16
}

func (s uint16Sorter) Len() int {
	return len(s.s)
}

func (s uint16Sorter) Less(i, j int) bool {
	return s.s[i] < s.s[j]
}

func (s uint16Sorter) Swap(i, j int) {
	s.s[i], s.s[j] = s.s[j], s.s[i]
}

func main() {
	// Open payloads.ts.go.
	f, err := os.Open("payloads.ts.go")
	if err != nil {
		panic(err)
	}
	defer f.Close()

	// Go through each line.
	scanner := bufio.NewScanner(f)
	structCases := map[string]uint16{}
	idCases := map[uint16]string{}
	for scanner.Scan() {
		// Get the line.
		line := scanner.Text()

		// Check if we should generate the serializer.
		if strings.HasPrefix(line, "// generate_serializer_case") {
			// Split the line.
			split := strings.Split(line, " ")

			// Get the name and id.
			name := split[2]
			idS := split[3]

			// Turn the id into uint16.
			id64, err := strconv.ParseUint(idS, 10, 16)
			if err != nil {
				panic(err)
			}
			id := uint16(id64)

			// Add the case.
			structCases[name] = id
			idCases[id] = name
		}
	}

	// Generate the functions.
	parseFunction := `// Parses the payload. Returns nil if the payload is invalid.
func parsePayload(b []byte) any {
	// Get the uint16 from the first 2 bytes.
	if len(b) < 2 {
		return nil
	}
	id := binary.BigEndian.Uint16(b)
	b = b[2:]

	// Switch on the payload.
	switch id {`
	payloadIds := make([]uint16, 0, len(idCases))
	for id := range idCases {
		payloadIds = append(payloadIds, id)
	}
	sort.Sort(uint16Sorter{payloadIds})
	for _, id := range payloadIds {
		name := idCases[id]
		parseFunction += `
	case ` + strconv.FormatUint(uint64(id), 10) + `:
		// Parse the ` + name + ` payload.
		p := &` + name + `{}
		err := msgpack.Unmarshal(b, p)
		if err != nil {
			return nil
		}
		return p`
	}
	parseFunction += `
	}
	return nil
}`
	serializeFunction := `// Serializes the payload. Returns an error if the payload is invalid.
func serializePayload(p any) ([]byte, error) {
	// Switch on the payload.
	var id uint16
	switch p.(type) {`
	names := make([]string, 0, len(structCases))
	for name := range structCases {
		names = append(names, name)
	}
	sort.Strings(names)
	for _, name := range names {
		id := structCases[name]
		serializeFunction += `
	case *` + name + `, ` + name + `:
		id = ` + strconv.FormatUint(uint64(id), 10)
	}
	serializeFunction += `
	default:
		return nil, errors.New("invalid payload")
	}

	// Marshal the payload.
	b, err := msgpack.Marshal(p)
	if err != nil {
		return nil, err
	}

	// Prepend the id.
	b2 := make([]byte, 2+len(b))
	binary.BigEndian.PutUint16(b2, id)
	copy(b2[2:], b)
	return b2, nil
}`

	// Create the file.
	file := `package gateway

// Code generated by generate_serializer.go. DO NOT EDIT.

import (
	"encoding/binary"
	"errors"

	"github.com/vmihailenco/msgpack/v5"
)

`
	file += parseFunction + "\n\n" + serializeFunction + "\n"
	err = os.WriteFile("serializer_gen.go", []byte(file), 0644)
	if err != nil {
		panic(err)
	}
}
